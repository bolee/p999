{0: {'content': u'<p>It\'s not that <code>i--</code> is faster than <code>i++</code>. Actually, they\'re both as fast.</p>\n\n<p>What takes time in ascending loops, is to evaluate, for each <code>i</code>, the size of your array. In this loop:</p>\n\n<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">for</span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> array</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">--;</span><span class="pln"> </span><span class="pun">)</span></code></pre>\n\n<p>You evaluate <code>.length</code> only once, when you declare <code>i</code>, whereas for this loop</p>\n\n<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">for</span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;=</span><span class="pln"> array</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++</span><span class="pln"> </span><span class="pun">)</span></code></pre>\n\n<p>you evaluate <code>.length</code> each time you increment <code>i</code>, when you check if <code>i &lt;= array.length</code>.</p>\n\n<p>In most cases you <strong>shouldn\'t even worry about this kind of optimization</strong>.</p>\n', 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'alestanis'}, 1: {'content': u'<p>I try to give a broad picture with this answer.</p>\n\n<p><em>The following thoughts in brackets <strong>was</strong> my belief until I have just recently tested the issue:</em><br/>\n[[In terms of <strong>low level languages</strong> like c/c++, the code is compiled so that the processor has a special conditional jump command when a variable is zero(or non zero).<br/>\nAlso, if you care about this much optimization, you could go ++i instead of i++, because ++i is a single processor command whereas i++ means j=i+1, i=j.]]</p>\n\n<p>Really fast loops can be done by unrolling them: </p>\n\n<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">for</span><span class="pun">(</span><span class="pln">i</span><span class="pun">=</span><span class="lit">800000</span><span class="pun">;</span><span class="pln">i</span><span class="pun">&gt;</span><span class="lit">0</span><span class="pun">;--</span><span class="pln">i</span><span class="pun">)</span><span class="pln">\n  do_it</span><span class="pun">(</span><span class="pln">i</span><span class="pun">);</span></code></pre>\n\n<p>can be way slower than:</p>\n\n<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">for</span><span class="pun">(</span><span class="pln">i</span><span class="pun">=</span><span class="lit">800000</span><span class="pun">;</span><span class="pln">i</span><span class="pun">&gt;</span><span class="lit">0</span><span class="pun">;</span><span class="pln">i</span><span class="pun">-=</span><span class="lit">8</span><span class="pun">)</span><span class="pln">\n</span><span class="pun">{</span><span class="pln">\n    do_it</span><span class="pun">(</span><span class="pln">i</span><span class="pun">);</span><span class="pln"> do_it</span><span class="pun">(</span><span class="pln">i</span><span class="pun">-</span><span class="lit">1</span><span class="pun">);</span><span class="pln"> do_it</span><span class="pun">(</span><span class="pln">i</span><span class="pun">-</span><span class="lit">2</span><span class="pun">);</span><span class="pln"> </span><span class="pun">...</span><span class="pln"> do_it</span><span class="pun">(</span><span class="pln">i</span><span class="pun">-</span><span class="lit">7</span><span class="pun">);</span><span class="pln">\n</span><span class="pun">}</span></code></pre>\n\n<p>but the reasons for this can be quite complicated (just to mention, there are the issues of processor command preprocessing and cache handling in the game).</p>\n\n<p>In terms of <strong>high level languages</strong> -- like <strong>javascript</strong> as you asked -- you can optimize things if you rely on libraries, built-in functions for looping. Let them decide how it is best done.</p>\n\n<p>Consequently, in <strong>JavaScript</strong> I would suggest using something like</p>\n\n<pre class="default prettyprint prettyprinted" style=""><code><span class="pln">array</span><span class="pun">.</span><span class="pln">forEach</span><span class="pun">(</span><span class="kwd">function</span><span class="pun">(</span><span class="pln">i</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">\n    do_it</span><span class="pun">(</span><span class="pln">i</span><span class="pun">);</span><span class="pln">\n</span><span class="pun">});</span></code></pre>\n\n<p>It is also less error-prone and browsers have a chance to optimize your code.</p>\n\n<p>Moreover, also for low level languages the best practice is to use some smart library function for complex, looped operations if it is possible.<br/>\nThose libraries can also put things multi-threaded behind your back.</p>\n\n<p><strong>EDIT:</strong></p>\n\n<p>Thanks for the comments, I did a bit more scrutiny and it turns out that in c/c++,\neven for 5e9 = (50,000x100,000) operations, <strong>there is no difference between going up and down</strong> if the testing is done against a constant like @alestanis says. So <code>--i</code> happens to be rather a "posh" thing. It only makes you look like a better programmer. :) </p>\n\n<p>On the other hand, for-unrolling in this 5e9 situation has brought me down from (12s to 2.5 when I went by 10s, and to 2.1 when I went by 20s). It was without optimization, optimization has brought things down to unmeasureable little time. :)</p>\n\n<p><strong>All in all:</strong> keep i--/i++ and ++i/i++ differences to the job interviews, stick to <code>array.forEach</code> or other complex library functions when available.  ;) </p>\n', 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'Barnabas Szabolcs'}, 2: {'content': u'<p><code>i--</code> is as fast as <code>i++</code></p>\n\n<p>This code below is as fast as yours, but uses an extra variable:</p>\n\n<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">var</span><span class="pln"> up </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Things</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln">\n</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> up</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">\n    </span><span class="typ">Things</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln">\n</span><span class="pun">};</span></code></pre>\n\n<p>The recommendation is to NOT evaluate the size of the array each time. For big arrays one can see the performance degradation.</p>\n', 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'RoManiac'}, 3: {'content': u'<p>It depends on placement of your array in memory and hit ratio of memory pages while you are accessing that array. </p>\n\n<p>In some cases accessing array members in column order is faster than row order because of increase in hit ratio.</p>\n', 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'Cody'}, 4: {'content': u'<p>I\'ve seen the same recommendation in Sublime Text 2.</p>\n\n<p>Like it was already said, the main improvement is not evaluating the array\'s length at each iteration in the for loop. This a well-known optimization technique and particularly efficient in JavaScript when the array is part of the HTML document (doing a <code>for</code> for the all the <code>li</code> elements).</p>\n\n<p>For example, </p>\n\n<p><code>for (var i = 0; i &lt; document.getElementsByTagName(\'li\').length; i++)</code> </p>\n\n<p>is much slower than </p>\n\n<p><code>for (var i = 0, len = document.getElementsByTagName(\'li\').length; i &lt; len; i++)</code></p>\n\n<p>From where I\'m standing, the main improvement in the form in your question is the fact that it doesn\'t declare an extra variable (<code>len</code> in my example)</p>\n\n<p>But if you ask me, the whole point is not about the <code>i++</code> vs <code>i--</code> optimization, but about not having to evaluate the length of the array at each iteration (you can see a benchmark test on <a href="http://jsperf.com/for-length-bench" rel="nofollow">jsperf</a>).</p>\n', 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'Akbar Bayati'}, 5: {'content': u'<p>Its not the -- or ++, is the compare operation, with -- you can use a compare with 0, while with ++ you need to compare with the length. On the processor compare with zero is noramally available, while compare with a finite integer requires a subtraction,</p>\n\n<p><code>a++ &lt; length</code></p>\n\n<p>is actually compiled as</p>\n\n<p/><pre class="default prettyprint prettyprinted" style=""><code class="default prettyprint"><span class="pln">\n a</span><span class="pun">++</span><p/><span class="pln">\n\n</span><code><span class="pln"> test </span><span class="pun">(</span><span class="pln">a</span><span class="pun">-</span><span class="pln">length</span><span class="pun">)</span></code></code></pre><code>\n\n</code><p><code/>&lt;\nSo takes longer on the processor when compiled</p>\n', 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'BBog'}, 6: {'content': u'<p>I don\'t think that it makes sense to say that <code>i--</code> is faster that <code>i++</code> in JavaScript.</p>\n\n<p><strong>First of all</strong>, it totally depends on JavaScript engine implementation. </p>\n\n<p><strong>Secondly</strong>, provided that simplest constructs JIT\'ed and translated to native instructions, then <code>i++</code> vs <code>i--</code> will totally depend on the CPU that executes it. That is, on ARMs (mobile phones) it\'s faster to go down to 0 since decrement and compare to zero are executed in a single instruction.</p>\n\n<p>Probably, you thought that one was waster than the other because suggested way is</p>\n\n<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">for</span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> array</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">--;</span><span class="pln"> </span><span class="pun">)</span></code></pre>\n\n<p>but suggested way is not because one faster then the other, but simply because if you write</p>\n\n<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">for</span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> array</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span></code></pre>\n\n<p>then on every iteration <code>array.length</code> had to be evaluated (smarter JavaScript engine perhaps could figure out that loop won\'t change length of the array). Even though it looks like a simple statement, it\'s actually some function that gets called under the hood by the JavaScript engine.</p>\n\n<p>The other reason, why <code>i--</code> could be considered "faster" is because JavaScript engine needs to allocate only one internal variable to control the loop (variable to the <code>var i</code>). If you compared to array.length or to some other variable then there had to be more than one internal variable to control the loop, and the number of internal variables are limited asset of a JavaScript engine. The less variables are used in a loop the more change JIT has for optimization. That\'s why <code>i--</code> could be considered faster...</p>\n', 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'Dr BDO Adams'}, 7: {'content': u'<p>Since, you are interesting in such subject take a look into Greg Reimer\'s Weblog </p>\n\n<p><strong>JavaScript Loop Benchmark</strong> =&gt; <a href="https://blogs.oracle.com/greimer/entry/best_way_to_code_a">https://blogs.oracle.com/greimer/entry/best_way_to_code_a</a>, </p>\n\n<p>"I built a loop benchmarking test suite for different ways of coding loops in JavaScript. There are a few of these out there already, but I didn\'t find any that acknowledged the difference between native arrays and HTML collections."</p>\n\n<p>You can also <strong>performance a loop</strong> test in </p>\n\n<p><a href="https://blogs.oracle.com/greimer/resource/loop-test.html">https://blogs.oracle.com/greimer/resource/loop-test.html</a></p>\n', 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'Pavel'}, 8: {'content': u'<h3>short answer</h3>\n\n<p>For normal code, especially in a high level language like javascript, is no performance  difference in <code>i++</code> and <code>i--</code>.</p>\n\n<p>The performance criteria is the use in the for loop and the <em>compare</em> statement.</p>\n\n<p>This <strong>applies to all high level languages</strong> and is mostly independent from the use of javascript. The explanation is the resulting assembler code at the bottom line.</p>\n\n<h3>detailed explanation</h3>\n\n<p>A performance difference may occur in a loop.\nThe background is that on the <strong>assembler code</strong> level you can see that a <code>compare with 0</code> is just one statement which doesn\'t need an additional register.\n<br/>This compare is issued on every pass of the loop and may result in a measurable performance improvement.</p>\n\nfor(var i = array.length; i--; )\n\n<p>Will be evaluated to a <em>pseudo code</em> like this:</p>\n\n<pre class="default prettyprint prettyprinted" style=""><code><span class="pln"> i</span><span class="pun">=</span><span class="pln">array</span><span class="pun">.</span><span class="pln">length\n </span><span class="pun">:</span><span class="pln">LOOP_START\n decrement i\n </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">[</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">]</span><span class="pln"> </span><span class="kwd">goto</span><span class="pln"> </span><span class="pun">:</span><span class="pln">LOOP_END\n </span><span class="pun">...</span><span class="pln"> BODY_CODE\n </span><span class="pun">:</span><span class="pln">LOOP_END</span></code></pre>\n\n<p>Note that <strong>0</strong> is a literal or in other words a constant value.</p>\n\nfor(var i = 0 ; i &lt; array.length; i++ )\n\n<p>Will be evaluated to a <em>pseudo code</em> like this (normal interpreter optimisation supposed):</p>\n\n<pre class="default prettyprint prettyprinted" style=""><code><span class="pln"> </span><span class="kwd">end</span><span class="pun">=</span><span class="pln">array</span><span class="pun">.</span><span class="pln">length\n i</span><span class="pun">=</span><span class="lit">0</span><span class="pln">\n </span><span class="pun">:</span><span class="pln">LOOP_START\n </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">[</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> </span><span class="kwd">end</span><span class="pln"> </span><span class="pun">]</span><span class="pln"> </span><span class="kwd">goto</span><span class="pln"> </span><span class="pun">:</span><span class="pln">LOOP_END\n increment i\n </span><span class="pun">...</span><span class="pln"> BODY_CODE\n </span><span class="pun">:</span><span class="pln">LOOP_END</span></code></pre>\n\n<p>Note that <strong>end</strong> is a variable which needs a cpu register. This may invoke an <em>additional register swapping</em> in the code and needs a <em>more expensive compare statement</em> in the if statement.</p>\n\n<h3>just my 5 cents</h3>\n\n<p>For a high level language readability, which facilitates maintainability, is more important as a minor performance improvement.\n<br/>Normally the <em>classic</em> iteration from array <em>start to end</em> is better.\n<br/>The more quicker iteration from array <em>end to start</em> results in the possibly unwanted reversed sequence.</p>\n\n<h3>post scriptum</h3>\n\n<p>As asked in a comment:\nThe difference of <code>--i</code> and <code>i--</code> is in the evaluation of i before or after the decrementing.</p>\n\n<p>The best explanation is to try it out ;-) Here is a <em>bash</em> example.</p>\n\n<pre class="default prettyprint prettyprinted" style=""><code><span class="pln"> </span><span class="pun">%</span><span class="pln"> i</span><span class="pun">=</span><span class="lit">10</span><span class="pun">;</span><span class="pln"> echo </span><span class="str">"$((--i)) --&gt; $i"</span><span class="pln">\n </span><span class="lit">9</span><span class="pln"> </span><span class="pun">--&gt;</span><span class="pln"> </span><span class="lit">9</span><span class="pln">\n </span><span class="pun">%</span><span class="pln"> i</span><span class="pun">=</span><span class="lit">10</span><span class="pun">;</span><span class="pln"> echo </span><span class="str">"$((i--)) --&gt; $i"</span><span class="pln">\n </span><span class="lit">10</span><span class="pln"> </span><span class="pun">--&gt;</span><span class="pln"> </span><span class="lit">9</span></code></pre>\n', 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'dreamcrash'}, 9: {'content': u'<p>to cut it short: <strong>There is absolutely no difference in doing this in JavaScript.</strong></p>\n\n<p>First of all you can test it yourself:</p>\n\n<ul><li><p><a href="http://jsperf.com/for-loop-implicit-index-test">jsperf - is an excellent platform for all sorts of performance\ntesting in JS</a>.</p></li>\n<li><p><a href="http://jsperf.com/inc-vs-dec-2">http://jsperf.com/inc-vs-dec-2</a></p></li>\n</ul><p>Not only you can test and run any script in any js-library, but you also has access to whole bunch of previously written scripts, as well as to see difference between execution time in different browsers on different platforms.</p>\n\n<p>So as far as you can see there is no difference between performance in any environment.</p>\n\n<p>If you want to improve performance of your script, things you can try to do:</p>\n\n<ol><li>have a var a = array.length; so that you will not be calculating its value each time in the loop</li>\n<li>do loop unrolling <a href="http://en.wikipedia.org/wiki/Loop_unwinding">http://en.wikipedia.org/wiki/Loop_unwinding</a></li>\n</ol><p>But you have to understand that the improvement you can gain will be so insignificant, that mostly you should not even care about it.</p>\n\n<p><strong>My own opinion why such a misconception (Dec vs Inc) appeared</strong></p>\n\n<p>Long long time ago there was a common machine instruction DSZ (Decrement and Skip on Zero). People who programmed in assembly language used this instruction to implement loops in order to save a register. Now this ancient facts are obsolete and I am pretty sure you will not find any performance in any language using this pseudo improvement.</p>\n\n<p>I think the only way such knowledge can propagate in our time is when you read other\'s person code, see such construction and ask why was it implemented and here the answer: "it improves performance because it compares to zero". You became bewildered of higher knowledge of your colleague and think to use it to be much smarter :-) </p>\n', 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'kojiro'}, 10: {'content': u"<p>Last time i bothered about it was when writing 6502 assembly (8bit, yeah!).  The big gain is that most arithmetic operations (especially decrements) updated a set of flags, one of them was <code>Z</code>, the 'reached zero' indicator.</p>\n\n<p>So, at the end of the loop you just did two instructions: <code>DEC</code> (decrement) and <code>JNZ</code> (jump if not zero), no comparison needed!</p>\n", 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'H.-Dirk Schmitt'}, 11: {'content': u'<p>Sometimes making some very minor changes to the way that we write our code can make a big difference to how quickly our code actually runs. One area where a minor code change can make a big difference to execution times is where we have a for loop that is processing an array. Where the array is of elements on the web page (such as radio buttons) the change has the biggest effect but it is still worth applying this change even where the array is internal to the Javascript code.</p>\n\n<p>The conventional way of coding a for loop to process an array lis like this:</p>\n\n<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> myArray</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{...</span></code></pre>\n\n<p>The problem with this is that evaluating the length of the array using myArray.length takes time and the way that we have coded the loop means that this evaluation has to be performed every time around the loop. If the array contains 1000 elements then the length of the array will be evaluated 1001 times. If we were looking at radio buttons and had myForm.myButtons.length then it will take even longer to evaluate since the appropriate group of buttons within the specified form must first be located before the length can be evaluated each time around the loop.</p>\n\n<p>Obviously we don\'t expect the length of the array to change while we are processing it so all of these recalculations of the length are just adding unnecessarily to the processing time. (Of course if you have code inside the loop that adds or removes array entries then the array size can change between iterations and so we can\'t change the code that tests for it)</p>\n\n<p>What we can do to correct this for a loop where the size is fixed is to evaluate the length once at the start of the loop and save it in a variable. We can then test the variable to decide when to terminate the loop. This is much faster than evaluating the array length each time particularly when the array contains more than just a few entries or is part of the web page.</p>\n\n<p>The code to do this is:</p>\n\n<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">var</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> myArray</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> j</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{...</span></code></pre>\n\n<p>So now we only evaluate the size of the array once and test our loop counter against the variable that holds that value each time around the loop. This extra variable can be accessed much faster than evaluating the size of the array and so our code will run much faster than before. We just have one extra variable in our script.</p>\n\n<p>Often it doesn\'t matter what order we process the array in as long as all of the entries in the array get processed. Where this is the case we can make our code slightly faster by doing away with the extra variable that we just added and processing the array in reverse order.</p>\n\n<p>The final code that processes our array in the most efficient way possible is:</p>\n\n<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> myArray</span><span class="pun">.</span><span class="pln">length</span><span class="pun">-</span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">--)</span><span class="pln"> </span><span class="pun">{...</span></code></pre>\n\n<p>This code still only evaluates the size of the array once at the start but instead of comparing the loop counter with a variable we compare it with a constant. Since a constant is even more effective to access than a variable and since we have one fewer assignment statement than before our third version of the code is now slightly more efficient than the second version and vastly more efficient than the first.</p>\n', 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'Salvador Dali'}, 12: {'content': u'<p><code>for(var i = array.length; i--; )</code> is not much faster. But when you replace <code>array.length</code> with <code>super_puper_function()</code>, that may be <strong>significantly</strong> faster (since it\'s called every iteration). That\'s the difference.</p>\n\n<p>If you gonna change it in 2014, you won\'t think about optimization. If you gonna change it with "Search &amp; Replace", you won\'t think about optimization. If you have no time, you don\'t think about optimization. But now, you\'ve got time to think about it.</p>\n\n<p>P. S. <code>i--</code> is not faster than <code>i++</code>. :)</p>\n', 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'Javier'}, 13: {'content': u'<p>First, <code>i++</code> and <code>i--</code> take exactly the same time on any programming language, including JavaScript.</p>\n\n<p>The following code take much different time.</p>\n\n<p><em>Fast:</em></p>\n\n<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> len </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Things</span><span class="pun">.</span><span class="pln">length </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;=</span><span class="pln"> len</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Things</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">};</span></code></pre>\n\n<p><em>Slow:</em></p>\n\n<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="typ">Things</span><span class="pun">.</span><span class="pln">length </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Things</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">};</span></code></pre>\n\n<p>Therefore the following code take different time too.</p>\n\n<p><em>Fast:</em></p>\n\n<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Things</span><span class="pun">.</span><span class="pln">length </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">--)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Things</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">};</span></code></pre>\n\n<p><em>Slow:</em></p>\n\n<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="typ">Things</span><span class="pun">.</span><span class="pln">length </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Things</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">};</span></code></pre>\n\n<p>P.S. <em>Slow</em> is slow only for a few languages (JavaScript engines) because of compiler\'s optimization. The best way is to use <strong>\'&lt;\' instead \'&lt;=\'</strong> (or \'=\') and <strong>\'--i\' instead \'i--\'</strong>.</p>\n', 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'Kunwar Siddharth Singh'}, 14: {'content': u'<p>In very simple words</p>\n\n<p>"i-- and i++. Actually, they\'re both takes the same time".</p>\n\n<p>but in this case when you have incremental operation.. processor evaluate the .length every time variable is incremented by 1 and in case of decrement.. particularly in this case, it will evaluate .length only once till we get 0.     </p>\n', 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'Dmitry'}, 15: {'content': u"<p>This is not depends on the -- or ++ sign</p>\n\n<p>But it's depends on conditions you apply in the loop.</p>\n\n<p>for example:</p>\n\n<p>your loop is static value for variable than is more faster than your loop which check conditions every time.</p>\n\n<p>Like length of array or other conditions.</p>\n\n<p>But don't worry about this optimization because this time effects in nano seconds.</p>\n", 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'Altaveron'}, 16: {'content': u"<p>Well, I don't know about JavaScript, it should really be just a matter of re-evaluation array length and maybe something to do with the associative arrays (if you only decrement, it is unlikely new entries would need to be allocated - if the array is dense, that is. someone may optimize for that).</p>\n\n<p>In low-level assembly, there is a looping instruction, called DJNZ (decrement and jump if non-zero). So the decrement and jump is all in one instruction, making it possibly ever-so-slightly faster than INC and JL / JB (increment, jump if less than / jump if below). Also, comparing against zero is simpler than comparing against another number. But all that is really marginal and also depends on target architecture (could make difference e.g. on Arm in a smartphone).</p>\n\n<p>I wouldn't expect this low-level differences to have so great impact on interpreted languages, I just haven't seen DJNZ among the responses so I thought I would share an interesting thought.</p>\n", 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'iHuman'}, 17: {'content': u'<p>Not a lot of time consumed in the i-- or i++,<br/>\nif you go deep inside the CPU architecture the ++ is more speedy than the --,<br/>\nsince the -- operation will do the 2\'s complement but it happend inside the hardware so this will make it speedy and no major difference between the ++ and -- also these operations are considered of the least time consumed in the CPU.  </p>\n\n<p>the <strong>for loop</strong> runs like this :<br/>\n- initialize the variable once at the start.<br/>\n- check the constrain in the second operand of the loop &lt;,&gt;, &lt;= ....<br/>\n- then apply the loop.<br/>\n- increment the loop and loop again throw these processes again.  </p>\n\n<p>so,  </p>\n\n<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">for</span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> array</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">--;</span><span class="pln"> </span><span class="pun">)</span><span class="pln">  </span></code></pre>\n\n<p>will calculate the array length only once at the start and this is not a lot of time,  </p>\n\n<p>but:  </p>\n\n<pre class="default prettyprint prettyprinted" style=""><code><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Things</span><span class="pun">.</span><span class="pln">length </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">--)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">\n   </span><span class="typ">Things</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln">\n</span><span class="pun">};</span><span class="pln">  </span></code></pre>\n\n<p>it will calculate the length at each loop so it will consume a lot of time</p>\n', 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'Arvind Kanjariya'}, 18: {'content': u'<p>It <em>used</em> to be said that --i was faster (in C++) because there is only one result, the decremented value. i-- needs to store the decremented value back to i and also retain the original value as the result (j = i--;). In most compilers this used up two registers rather than one which could cause another variable to have to be written to memory rather than retained as a register variable.</p>\n\n<p>I agree with those others that have said it makes no difference these days.</p>\n', 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'the swine'}, 19: {'content': u'<p><strong>Literal answer:</strong> <code>i--</code> is generally faster because it doesn\'t have to run a comparison to 0 each time it runs, test results on various methods are below:</p>\n\n<p><strong>Test results:</strong> As "proven" by <a href="http://jsperf.com/fastest-array-loops-in-javascript/15" rel="nofollow">this</a> jsPerf, <code>arr.pop()</code> is actually the fastest loop by far. But, focusing on <code>--i</code>, <code>i--</code>, <code>i++</code> and <code>++i</code> as you asked in your question, here are jsPerf (they are from multiple jsPerf\'s, please see sources below) results summarized:</p>\n\n<p><code>--i</code> and <code>i--</code> are the same in Firefox while <code>i--</code> is faster in Chrome.</p>\n\n<p>In Chrome a basic for loop (<code>for (var i = 0; i &lt; arr.length; i++)</code>) is faster than <code>i--</code> and <code>--i</code> while in Firefox it\'s slower.</p>\n\n<p>In Both Chrome and Firefox a cached <code>arr.length</code> is significantly faster with Chrome ahead by about 170,000 ops/sec.</p>\n\n<p>Without a significant difference, <code>++i</code> is faster than <code>i++</code> in most browsers, AFAIK, it\'s never the other way around in any browser.</p>\n\n<p><strong>Shorter summary:</strong> <code>arr.pop()</code> is the fastest loop by far; for the specifically mentioned loops, <code>i--</code> is the fastest loop.</p>\n\n<p><strong>Sources:</strong> <a href="http://jsperf.com/fastest-array-loops-in-javascript/15" rel="nofollow">http://jsperf.com/fastest-array-loops-in-javascript/15</a>, <a href="http://jsperf.com/ipp-vs-ppi-2" rel="nofollow">http://jsperf.com/ipp-vs-ppi-2</a></p>\n\n<p>I hope this answers your question.</p>\n', 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'Omar Freewan'}, 20: {'content': u"<p>Wouldn't the compiler cache .length, and therefore it makes no difference if you are comparing 0 or .length? I guess this is very specific to the compiler or interpreter you are dealing with.</p>\n\n<p>I would say if you are using a well optimised compiler or interpreter then you shouldn't worry about this, it is for the language developers to worry about.</p>\n", 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'Ant'}, 21: {'content': u"<p>This is just a guess, but maybe it's because it's easier for the processor to compare something with 0 ( i &gt;= 0 ) instead of with another value ( i &lt; Things.length).</p>\n", 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'A.M.K'}, 22: {'content': u'<p><code>++</code> vs. <code>--</code> does not matter because JavaScript is an interpreted language, not a compiled language. Each instruction translates to more than one machine language and you should not care about the gory details.</p>\n\n<p>People who are talking about using <code>--</code> (or <code>++</code>) to make efficient use of assembly instructions are wrong. These instruction apply to integer arithmetic and there are <a href="http://www.hunlock.com/blogs/The_Complete_Javascript_Number_Reference" rel="nofollow">no integers in JavaScript, just numbers</a>.</p>\n\n<p>You should write readable code.</p>\n', 'date': '2012-10-30 10:19:13', 'supply': {0: {'ragatskynet': {'2012-10-30 10:13:38': "is it worth to introduce a variable for array.length and use it in the for loop's head?"}}, 1: {'Jon': {'2012-10-30 10:13:38': '@ragatskynet: No, unless you are setting up a benchmark and want to make a point.'}}, 2: {'alestanis': {'2012-10-30 10:13:38': u'@ragatskynet It depends: will it be faster to evaluate <code>.length</code> a certain number of times or to declare and define a new variable? In most cases, this is premature (and wrong) optimization, unless your <code>length</code> is very expensive to evaluate.'}}, 3: {'Lightness Races in Orbit': {'2012-10-30 10:13:38': u"@Dr.Dredel: It's not the comparison - it's the evaluation. <code>0</code> is faster to evaluate than <code>array.length</code>. Well, supposedly."}}, 4: {'Dolphin': {'2012-10-30 10:13:38': u'What is worth mentioning is that we are talking about interpreted languages such as Ruby, Python. Compiled languages e.g. Java have optimizations on compiler level which which will "smooth" these differences to the point that it does not matter if <code>.length</code> is in declaration of <code>for loop</code> or not.'}}, 5: {'Afshin Mehrabani': {'2012-10-30 10:13:38': '+1, nice answer.'}}, 6: {'Saeed Neamati': {'2012-10-30 10:13:38': 'Really high-tech ;). Seems that we live in 2050. +1.'}}, 7: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': 'Thanks, I had the chance last year to have a glimpse on optimization techniques: we were given a loopy thing to be optimized in a competition. It was not much more complicated than this and I could not see if I could do anything sensible. Then some guys using smart libraries and for-unlooping had 10 to 20 times faster codes. I was shocked... then went ahead unlooping an image filtering function: 4x speed-up. It is surprising that you can be faster by doing actually more unit operations.'}}, 8: {'jalf': {'2012-10-30 10:13:38': 'The key word is "can be". Your unrolled loop might also be slower than the original one. When optimizing, always measure so you know exactly what impact your changes had.'}}, 9: {'Barnabas Szabolcs': {'2012-10-30 10:13:38': u"@jalf true indeed, +1. Different unlooping lenghts(>=1) are different in efficiency. \n\nThat is why it is more convenient to leave this job to libraries if possible, not to mention that browsers run on different architectures so it might be better if they decide how to do <code>array.each(...)</code>. I don't think they would try and experiment with unlooping plain for-loops."}}, 10: {'Pavel': {'2012-10-30 10:13:38': "You are plainly wrong here. Now loop control needs extra internal variable (i and up) and depending on JavaScript engine this may limit potential to optimize the code. JITs will translate simple loops to direct machine opcodes, but if loops have too many variables then JIT won't be able to optimize as good. Generally, it's limited by architecture or cpu registers that JIT uses. Initializing once and going down simply cleanest solution and that's why it's recommended all over the place."}}, 11: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The point is the 'compare to 0' - see my answer for further explanation."}}, 12: {'David Cowden': {'2012-10-30 10:13:38': 'If only the OP had asked why traversing the same matrix in different orders can take different amounts of time..'}}, 13: {'Akbar Bayati': {'2012-10-30 10:13:38': 'Considering that in Operating Systems that their memory management is based on Paging, when a process needs a data that is not in cached pages , occurs a page fault in OS and it must bring target page to CPU cache and replace with another page, therefore , causes overhead in processing that takes more time than when target page is in \nCPU cache. Suppose that we defined a large array that each row in it is bigger than page OS size and we access it in row order, in this case page fault ratio increases and result is slower than column order access to that array.'}}, 14: {'David Cowden': {'2012-10-30 10:13:38': "What you're trying to say is correct, yes. (="}}, 15: {'kojiro': {'2012-10-30 10:13:38': u'I have to take exception to the word <i>calculating</i> here. See my comment on <a href="http://stackoverflow.com/a/13145309/418413">Pavel\'s answer</a>. The ECMA spec states that the array length is not calculated when you refer to it.'}}, 16: {'BBog': {'2012-10-30 10:13:38': "Would 'evaluating' be a better choice? Interesting fact btw, I did not know that"}}, 17: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': "The additional variable will be eliminated by the optimizer of a common interpreter/compiler. The same applies to the array.length evaluation. The point is the 'compare to 0' - see my answer for further explanation."}}, 18: {'kojiro': {'2012-10-30 10:13:38': u'@H.-DirkSchmitt your common-sense answer aside, for long in the history of JavaScript the compiler did <i>not</i> optimize away the performance cost of the lookup chain. AFAIK V8 was the first to try.'}}, 19: {'BBog': {'2012-10-30 10:13:38': "@H.-DirkSchmitt just like kojiro said, this is as well-known and well-established trick. Even if it is no longer relevant in modern browsers, that still doesn't make it obsolete. Besides, doing it with either introducing a new variable for length or with the trick in OP's question, it's still the best way, imo. It's just a smart thing to do and good practice, I do not think it has anything to do with the fact that the compiler was optimized to take care of something often done in a bad way in JS"}}, 20: {'kojiro': {'2012-10-30 10:13:38': u'It\'s probably worth careful phrasing about how <code>array.length</code> is evaluated. The length is not <i>calculated</i> when you refer to it. (It\'s just <a href="http://ecma-international.org/ecma-262/5.1/#sec-15.4" rel="nofollow">a property that gets set whenever an array index is created or changed</a>). When there is additional cost, it is because the JS engine has not optimized the lookup chain for that name.'}}, 21: {'Pavel': {'2012-10-30 10:13:38': u"Well, not sure what Ecma spec says, but knowing about some internals of different JavaScript engines it's not simple <code>getLength(){return m_length; }</code> because there is some housekeeping involved. But if you try to think backwards: that would be quite ingenious to write array implementation where length would need to be actually calculated :)"}}, 22: {'kojiro': {'2012-10-30 10:13:38': u'the ECMA spec <i>requires</i> that the length property be already calculated. The <code>length</code> must be updated immediately whenever a property-that-is-an-array-index is added or changed.'}}, 23: {'Pavel': {'2012-10-30 10:13:38': "What I'm trying to say is that it's pretty hard to violate the spec if you try think about it."}}, 24: {'Yi Jiang': {'2012-10-30 10:13:38': "That post is 4 years old now. Given the speed (ha!) at which JavaScript engines have been updated, most of the advice is likely to be obsolete - the article doesn't even mention Chrome and it's shiny V8 JavaScript engine."}}, 25: {'dreamcrash': {'2012-10-30 10:13:38': 'Yep, i miss that detail, thanks for pointing that out. Event at that time there was not much of a difference between --i or i++ on the loop for.'}}, 26: {'Afshin Mehrabani': {'2012-10-30 10:13:38': u'1+ Good explanation. Just a question a little out of scope, could you please explain the difference between <code>--i</code> and <code>i--</code> also?'}}, 27: {'H.-Dirk Schmitt': {'2012-10-30 10:13:38': 'see post scriptum in answer'}}, 28: {'jrdn': {'2012-10-30 10:13:38': 'Interesting, but for your tests running under firefox 16.0.2 on win7, the decrement loop was 29% slower... EDIT: Disregard that. Repeated tests proved inconclusive, there is a surprising amount of noise in my test results for subsequent runs. Not quite sure why.'}}, 29: {'Salvador Dali': {'2012-10-30 10:13:38': 'that is browser dependent. Also there is a possibility that at that point of time JS engine was also working on something else and that decreased the performance.'}}, 30: {'jrdn': {'2012-10-30 10:13:38': 'Yeah I tried to account for that by closing everything else down and just running the tests. Still got wonky results. Very strange.'}}, 31: {'Pavel': {'2012-10-30 10:13:38': u"I think you missed the real point why going to zero is considered to be better in JavaScript. It's mostly because this way only one variable controls loop execution, e.g. this way optimizer/JITer has more room for improvement. Using <code>array.length</code> doesn't necessarily incur performance penalty, simply because JS virtual machine is smart enough to figure out if the array isn't modified by the loop's body. See my answer below."}}, 32: {'Pavel': {'2012-10-30 10:13:38': u"In case of JavaScript obviously it doesn't apply (since it runs on CPUs that don't have such op-codes). Most likely the real reason behind the <code>i--</code> vs <code>i++</code> is that with the former you don't introduce extra control variables in the loop's scope. See my answer below..."}}, 33: {'Javier': {'2012-10-30 10:13:38': "right, it really doesn't apply; but it's a very common C style, and it does looks cleaner to those of us that got used to that. :-)"}}, 34: {'Buksy': {'2012-10-30 10:13:38': "multiple nanoseconds loops can become seconds ... it's never a bad idea to optimize when you have time for it"}}, 35: {'Altaveron': {'2012-10-30 10:13:38': u'<code>var i = Things.length - 1; i &gt;= 0; i--</code> will calculate length 1 time too.'}}, 36: {'Omar Freewan': {'2012-10-30 10:13:38': 'yes i agree with you'}}, 37: {'harper': {'2012-10-30 10:13:38': '+1 Don\'t others have voted down. Although the repeated evaluation of .length is much more a problem than the actual inc/decrement, the check for the loop end might be important. My C compiler gives some warnings on loops like: "remark #1544-D: (ULP 13.1) Detected loop counting up. Recommend loops count down as detecting zeros is easier"'}}}, 'author': 'Daniel'}}